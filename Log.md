# 算法练习日志

- 记录当天练习内容，前期可能会优先一次性上传一部分积攒于本地未上传的学习笔记。

# 日志

- **20230411_力扣76 最小覆盖字串	滑动窗口git**

  **摘要：**
  
  滑动窗口，最小长度的应用。

  `vector<int>need(128,0)`统计字符串t中每个字符出现的次数，并存储到一个长度为128的数组`need`中。这里的128是ASCII码表中字符的数量，因此`need`可以看作是一个哈希表，用于快速查找每个字符出现的次数。

- **20230412_力扣59 螺旋数组**

  **摘要：**
  
  矩阵循环模拟

  边界一致性原则。：需要保证每一条边的遍历过程中边界正确，所以需要同一循环边界标准：左闭右开。

- **20230413_KWIC问题**

  摘要：用C++且采用主程序子程序的的思路实现KWIC问题，其中尝试运用`STL`的`vector`、`set`容器；在文件操作方面尝试使用C++中的`stream`类中的`ifstream`和`ofstream`。

- **20230414_KWIC_管道过滤器风格**
  
  **摘要：**
  
  用C++且采用管道过滤器的的思路实现KWIC问题，不过此次KWIC_pipe.cpp写的并不完善，之后将会重新研究修改。

- **20230416_力扣203&707_移除链表元素&设计链表**

  **摘要：**
  
  学习链表的基本类型、定义、操作。在移除链表元素的过程中，最好定义一个虚拟头节点。

- **20230417_力扣19&14&206_删除倒数第N个结点&交换结点&翻转链表**

  **摘要：**

  虚拟头节点的应用，双指针（快慢指针）的应用，链表结点交换、删除过程中临时变量`tmp`所储存的值。

- **20230418**

  **摘要：**

  力扣160_链表相交

  末尾对齐，然后移动curA到curB的位置再进行比较是否相同。

  git错误 error:` failed to push some refs to 'https://github.com/...`

  问题原因：远程库与本地库不一致造成的

  解决方法：`git pull --rebase origin master`   #把远程库中的更新合并到（pull=fetch+merge）本地库中，`–-rebase`的作用是取消掉本地库中刚刚的`commit`，并把他们接到更新后的版本库之中。

  力扣142_环形链表2

  双指针法（快慢指针），fast和slow的追及问题。都从head开始，Vf=2，Vs=1，fast先动，则一定相遇。
  
  关键：相遇节点到入口节点的距离=头节点到入口节点的距离

- **20230419**

  **摘要：**

  哈希表基础（后续将继续补充）

  力扣242_有效的字母异位词

- **20230423**

  **摘要：**

  哈希表算法题练习，力扣242完善，力扣349。

  有效字母异位词：数组作哈希表，利用a~z的ASCII码作统计字典记录字符出现次数，三次遍历。

  两个数组的交集：`unordered_set`的应用。

- **20230424**

  **摘要：**

  哈希表算法题练习，力扣350，力扣202

  数组交集2：利用`unordered_map`记录 `nums1` 中每个数字出现的次数，而 `unordered_set` 只能记录每个数字是否出现过，无法记录出现的次数。

  快乐数：`unordered_set`记录每次计算的sum值，然后进行比较。

- **20230426**

  **摘要：**

  哈希表算法题练习，力扣1，454，383

  1 两数之和：

  `unordered_map` {key：数据元素，value：数组元素对应的下标}。

  `auto iter=map.find(target-nums[i]);`//iter为一个指向哈希表中某个键值对的迭代器

  `return {iter->second,i};`//获取并返回符合条件的数的下标，{}直接快速创建一个`vector<int>`容器用来接收

  454 四数相加：

  分组，`undordered_map`中存放“一半”，对比寻找target-“一半”。key:a+b的数值，value:a+b数值出现的次数。一半为a+b，一半为c+d，判断目标条件为`a+b+c+d=0`。

  `umap.find(0 - (c + d)) != umap.end()`

  在C++中，`map`和`unordered_map`的`find()`方法都是返回一个迭代器，该迭代器指向指定键对应的键值对。如果指定的键不存在，`find()`方法会返回一个指向容器末尾的迭代器，即`map::end()或unordered_map::end()`。因此，在查找指定键对应的值时，需要判断返回的迭代器是否等于`end()`，以确定是否找到了指定的键。

  383 赎金信

  字符串字符对比，且只有26个小写字母，所以利用一个大小为26的数组构建哈希表，来统计字符出现的次数。

  `record[magazine[i]-'a'] ++`和`record[ransomNote[j]-'a']--`代表字符初选次数+1or-1

  `magazine[i]-'a'` 就是该字符与字符 a 的差值，也就是该字符在字母表中的索引位置。

- **20230427**

  **摘要：**

  哈希表练习，力扣15，力扣18

  15 三数之和

  不建议用哈希表方法，去重过于麻烦，用双指针法更好。

  a,b,c对应`num[i]`,`num[left]`,`num[right]`,需要去重。a一开始就进行去重，b和c再确定一组`result`之后去重。因为在一个排好序的数组中，如果已知`a+b+c=0`，则当b和c向中间移动时，如果它们的值和之前相同，那么它们组成的三元组也一定和之前的三元组相同。

  18 四数之和

  原理同15三数之和，利用双指针法。两次for循环遍历+双指针分别用来确定a,b,c,d四个元素。

  去重：两个for循环所确定的数直接去重，双指针确定的数在得到一个正确四元组后去重。剪枝操作提高效率。

- **20230428~20230429**

  **摘要：**

  这两天放羊了，去上海玩，参加了明日方舟音律联觉音乐会，不过确实很开心，很好的放松宣泄了一波，希望来年还有机会再参加。

  344 反转字符串

  双指针前后遍历，中间相遇终止，循环内交换i和j下标的值。

- **20230501**

  **摘要：**

  541 反转字符串2

  模拟，每隔 2k 个字符的前 k 个字符进行反转

- **20230502**

  **摘要：**

  JZ05 替换空格

  双指针从后往前替换,i---oldsize,j---newsize

  