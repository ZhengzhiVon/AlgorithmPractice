# 算法练习日志

- 记录当天练习内容，前期可能会优先一次性上传一部分积攒于本地未上传的学习笔记。

# 日志

- **20230411_力扣76 最小覆盖字串	滑动窗口git**

  摘要：滑动窗口，最小长度的应用。

  `vector<int>need(128,0)`统计字符串t中每个字符出现的次数，并存储到一个长度为128的数组`need`中。这里的128是ASCII码表中字符的数量，因此`need`可以看作是一个哈希表，用于快速查找每个字符出现的次数。

- **20230412_力扣59 螺旋数组**

  摘要：矩阵循环模拟

  边界一致性原则。：需要保证每一条边的遍历过程中边界正确，所以需要同一循环边界标准：左闭右开。

- **20230413_KWIC问题**

  摘要：用C++且采用主程序子程序的的思路实现KWIC问题，其中尝试运用`STL`的`vector`、`set`容器；在文件操作方面尝试使用C++中的`stream`类中的`ifstream`和`ofstream`。

- **20230414_KWIC_管道过滤器风格**
  
  摘要：用C++且采用管道过滤器的的思路实现KWIC问题，不过此次KWIC_pipe.cpp写的并不完善，之后将会重新研究修改。

- **20230416_力扣203&707_移除链表元素&设计链表**

  摘要：学习链表的基本类型、定义、操作。在移除链表元素的过程中，最好定义一个虚拟头节点。

- **20230417_力扣19&14&206_删除倒数第N个结点&交换结点&翻转链表**

  摘要：虚拟头节点的应用，双指针（快慢指针）的应用，链表结点交换、删除过程中临时变量tmp所储存的值。

- **20230418**

  摘要：

  力扣160_链表相交

  末尾对齐，然后移动curA到curB的位置再进行比较是否相同。

  git错误 error: failed to push some refs to 'https://github.com/...

  问题原因：远程库与本地库不一致造成的

  解决方法：git pull --rebase origin master   #把远程库中的更新合并到（pull=fetch+merge）本地库中，–-rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。

  力扣142_环形链表2

  双指针法（快慢指针），fast和slow的追及问题。都从head开始，Vf=2，Vs=1，fast先动，则一定相遇。
  
  关键：相遇节点到入口节点的距离=头节点到入口节点的距离

- **20230419**

  摘要：

  哈希表基础（后续将继续补充）

  力扣242_有效的字母异位词

- **20230423**

  摘要：

  哈希表算法题练习，力扣242完善，力扣349。

  有效字母异位词：数组作哈希表，利用a~z的ASCII码作统计字典记录字符出现次数，三次遍历。

  两个数组的交集：unordered_set的应用。

- **20230424**

  摘要：

  哈希表算法题练习，力扣350，力扣202

  数组交集2：利用unordered_map记录 nums1 中每个数字出现的次数，而 unordered_set 只能记录每个数字是否出现过，无法记录出现的次数。

  快乐数：unordered_set记录每次计算的sum值，然后进行比较。

- **20230426**

  摘要：

  哈希表算法题练习，力扣1

  1 两数之和：

  unordered_map, {key：数据元素，value：数组元素对应的下标}。

  auto iter=map.find(target-nums[i]);//iter为一个指向哈希表中某个键值对的迭代器

  return {iter->second,i};//获取并返回符合条件的数的下标，{}直接快速创建一个vector<int>容器用来接收

  454 四数相加：

  分组，undordered_map中存放“一半”，对比寻找target-“一半”。key:a+b的数值，value:a+b数值出现的次数。一半为a+b，一半为c+d，判断目标条件为a+b+c+d=0。

  umap.find(0 - (c + d)) != umap.end()

  在C++中，map和unordered_map的find()方法都是返回一个迭代器，该迭代器指向指定键对应的键值对。如果指定的键不存在，find()方法会返回一个指向容器末尾的迭代器，即map::end()或unordered_map::end()。因此，在查找指定键对应的值时，需要判断返回的迭代器是否等于end()，以确定是否找到了指定的键。

