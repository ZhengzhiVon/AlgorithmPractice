# 509 斐波那契数列

[参考](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dong-tai-g-1e688/)

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

## 暴力递归

```cpp
class Solution {
public:
    int fib(int n) {
        if (n == 1 || n == 2) return 1;
        return fib(n - 1) + fib(n - 2);
    }
};
//时间复杂度 O(2^n)
```

![image-20231008153227995](https://gitee.com/zhengzhivon/images/raw/master/imgs/image-20231008153227995.png)

通过递归树可见，存在大量重复计算，使时间复杂度过高。

## **带备忘录的递归解法**

带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

![image-20231008154957480](https://gitee.com/zhengzhivon/images/raw/master/imgs/image-20231008154957480.png)

```cpp
int fib(int N) {
    // 备忘录全初始化为0，之后储存计算过的数，当标记0被修改时，则说明已经计算过
    int memo[N + 1];
    memset(memo, 0, sizeof(memo));
    // 进行带备忘录的递归
    return dp(memo, N);
}

// 带着备忘录进行递归
int dp(int memo[], int n) {
    // base case
    if (n == 0 || n == 1) return n;
    // 已经计算过，不用再计算了
    if (memo[n] != 0) return memo[n];
    memo[n] = dp(memo, n - 1) + dp(memo, n - 2);
    return memo[n];
}

//时间复杂度是 O(n)
```

1. `int fib(int N)` 函数是计算斐波那契数列的入口函数。它接受一个整数 `N` 作为参数，表示要计算第 N 个斐波那契数。
2. 在函数内部，首先创建了一个名为 `memo` 的整数数组，其大小为 `N + 1`，并将其所有元素初始化为 0。这个数组用于存储已经计算过的斐波那契数，以避免重复计算。
3. 接着调用了 `dp` 函数，将 `memo` 数组和 `N` 作为参数传递给它，并返回 `dp(memo, N)` 的结果。
4. `int dp(int memo[], int n)` 函数是一个递归函数，用于计算第 `n` 个斐波那契数。
5. 在 `dp` 函数中，首先处理了基本情况（base case），如果 `n` 等于 0 或 1，直接返回 `n`，因为斐波那契数列的第一个数是 0，第二个数是 1。
6. 接着，检查是否已经计算过第 `n` 个斐波那契数，即检查 `memo[n]` 是否不等于 0。如果不等于 0，说明已经计算过，直接返回 `memo[n]` 的值。
7. **如果 `memo[n]` 等于 0，表示尚未计算过第 `n` 个斐波那契数，那么就进行递归计算。计算的方式是调用 `dp(memo, n - 1)` 和 `dp(memo, n - 2)`，分别计算第 `n-1` 和第 `n-2` 个斐波那契数。然后将这两个结果相加，得到第 `n` 个斐波那契数，并将其存储在 `memo[n]` 中。**
8. 最后，返回 `memo[n]` 的值，这就是第 `n` 个斐波那契数。

## dp数组递推解法（动态规划）

- 确定dp数组以及下标意义：第i个数的斐波那契数值是`dp[i]`
- 确定递推公式：`dp[i] = dp[i - 1] + dp[i - 2]`
- 初始化dp数组：`dp[0] = 0,dp[1] = 1`
- 确定遍历顺序：从前到后遍历

```cpp
class Solution {
public:
    int fib(int N) {
    if (N <= 1) return N;
    int dp[2];
    dp[0] = 0,dp[1] = 1;
    for (int i = 2; i <= N; i++) {
        int sum = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = sum;
    }
    return dp[1];
 }

//时间复杂度：O(n)
//空间复杂度：O(1)
```



1. `int fib(int N)` 函数是计算斐波那契数列的入口函数。它接受一个整数 `N` 作为参数，表示要计算第 N 个斐波那契数。
2. 如果输入参数 `N` 等于 0，函数直接返回 0，因为斐波那契数列的第一个数是 0。
3. 创建一个整数数组 `dp`，其大小为 `N + 1`，用于存储斐波那契数列的中间结果。`dp[i]` 表示第 `i` 个斐波那契数。
4. 在数组 `dp` 中，初始化前两个元素，即 `dp[0]` 和 `dp[1]`，分别为 0 和 1，这是斐波那契数列的前两个数。
5. 使用一个循环从 `i = 2` 开始，遍历到 `i = N`，进行状态转移计算。每一次迭代，都将 `dp[i]` 更新为 `dp[i - 1] + dp[i - 2]`，即前两个斐波那契数的和。
6. 循环执行完毕后，`dp[N]` 中存储的就是第 N 个斐波那契数的值。
7. 最后，返回 `dp[N]` 的值作为结果。