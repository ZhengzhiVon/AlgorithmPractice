# 242 有效的字母异位词

**给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。**

**说明:** 你可以假设字符串只包含小写字母。

```c++
示例 1: 输入: s = "anagram", t = "nagaram" 输出: true
示例 2: 输入: s = "rat", t = "car" 输出: false
```

## 思路&代码

- 题目中字符串只有小写字符，那么就可以定义一个数组，来**记录字符串s里字符出现的次数。**
- 定一个数组叫做`record`，大小为26 ，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。
- 把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**
- 统计字符串s中字符出现的次数：再遍历字符串s的时候，**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。** 
- 检查字符串t中是否出现了这些字符：在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。
- 最后检查，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**
- 最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。



定义一个长度为26的整型数组record，数组的下标表示字母的ASCII码减去字符'a'的ASCII码，即'a'对应下标0，'b'对应下标1，以此类推。然后遍历字符串s，对于每个字符，将其减去'a'的ASCII码得到对应的下标，然后在对应的数组中将计数器加1。

例如，当s为"leetcode"时，遍历过程如下：

- 对于第一个字符'l'，其ASCII码为108，减去'a'的ASCII码97之后得到下标11，将record[11]的值加1。
- 对于第二个字符'e'，其ASCII码为101，减去'a'的ASCII码97之后得到下标4，将record[4]的值加1。
- 对于第三个字符'e'，其ASCII码为101，减去'a'的ASCII码97之后得到下标4，将record[4]的值加1。
- 对于第四个字符't'，其ASCII码为116，减去'a'的ASCII码97之后得到下标19，将record[19]的值加1。
- 对于第五个字符'c'，其ASCII码为99，减去'a'的ASCII码97之后得到下标2，将record[2]的值加1。
- 对于第六个字符'o'，其ASCII码为111，减去'a'的ASCII码97之后得到下标14，将record[14]的值加1。
- 对于第七个字符'd'，其ASCII码为100，减去'a'的ASCII码97之后得到下标3，将record[3]的值加1。
- 对于第八个字符'e'，其ASCII码为101，减去'a'的ASCII码97之后得到下标4，将record[4]的值加1。

最终得到的数组record为[0,0,1,1,2,0,0,0,0,0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0]，表示字符串s中'a'出现了0次，'b'出现了0次，'c'出现了1次，以此类推。

这个算法的时间复杂度为O(n)，其中n为字符串s的长度。因为需要遍历字符串s一次，并且在数组中累加计数器的操作是O(1)的。空间复杂度为O(1)，因为只用了一个长度为26的数组来存储计数器。

## 代码

```c++
//数组哈希表，统计每个字符串个字符出现的次数，遍历三次，第一次遍历s，计数器++；第二次遍历t，字符计数器--。最后在遍历计数器数组，若存在索引下标处不为0，则说明s和t不是字母异位词，返回fasle
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        if(s.length()!=t.length()){
            return false;
        }
        for (int i = 0; i < s.size(); i++) {
            // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return false;
            }
        }
        // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};

//排序
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) {
            return false;
        }
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
//时间复杂度：0（nlogn），其中n为s的长度。排序的时间复杂度为O（nlogn），比较两个字符串是否相等时间复杂度为O（n），因此总体时间复杂度为C（nlogn+n）=O（nlogn）。
//空间复杂度：O（logn）。排序需要O（logn）的空间复杂度。

```

