# 哈希表基础

## 哈希表Hash

哈希表是根据**关键码**的值而**直接进行访问**的数据结构。

类比数组：哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。

**用途：哈希表都是用来快速判断一个元素是否出现集合里。**

枚举的话时间复杂度是O(n)，但使用哈希表的话， 只需要O(1)就可以做到。

## 哈希函数

将对象通过哈希函数转化为`hashCode`关键字，然后再映射为哈希表上的索引数字。

![image-20230423190241516](C:\Users\VoN\AppData\Roaming\Typora\typora-user-images\image-20230423190241516.png)

如果`hashCode`关键字得到的数值大于哈希表的大小，此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作。

如果对象的数量大于哈希表的大小，则可能会把几个不同对象映射到哈希表上同一个索引下表的位置，此时需要解决**哈希碰撞**。

## 哈希碰撞

### 拉链法

当两个对象的位置发生冲突，通过哈希函数计算出来在同一个索引下标之下，此时可以将发生冲突的元素存储在链表中。对象A->next=对象B

拉链法要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

### 线性探测法

需要依靠哈希表中的空位来解决碰撞问题，在产生冲突的索引下标位置的后面寻找空位放置后来冲突对象。

**一定要保证`tableSize`大于`dataSize`。**

## 常见的哈希结构

- 数组
- set （集合）
- map(映射)

### set

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

`std::unordered_set`底层实现为哈希表，`std::set` 和`std::multiset` 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以`key`值是有序的，但`key`不可以修改，改动`key`值会导致整棵树的错乱，所以**只能删除和增加。**

### map

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的。

当要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

map，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

**要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。